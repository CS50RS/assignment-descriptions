[Filter](#фільтр)
==================

Напишіть програму, яка застосовує фільтри до BMP файлів, як зазначено нижче.

     $ ./filter -r IMAGE.bmp REFLECTED.bmp
    

де `IMAGE.bmp` — це ім’я файлу зображення, а `REFLECTED.bmp` — це ім’я, дане вихідному файлу зображення.

[Опис](#фон)
------------------------

### Растрові зображення

Мабуть, найпростішим способом представлення зображення є сітка пікселів (тобто точок), кожна з яких може бути різного кольору. Тому для чорно-білих зображень нам потрібен 1 біт на піксель, оскільки 0 може представляти чорний, а 1 може представляти білий, як показано нижче.

![alt text](https://cs50.harvard.edu/x/2023/psets/4/filter/less/bitmap.png)

Отже, у цьому сенсі зображення є просто растровою картою (тобто картою бітів). Для більш барвистих зображень вам просто потрібно більше бітів на піксель. Формат файлу (наприклад, [BMP](https://en.wikipedia.org/wiki/BMP_file_format), [JPEG](https://en.wikipedia.org/wiki/JPEG) або [PNG](https://en.wikipedia.org/wiki.Portable_Network_Graphics)), який підтримує «24-бітний колір», використовує 24 біти на піксель. (BMP фактично підтримує 1-, 4-, 8-, 16-, 24- та 32-бітний колір.)

24-бітний BMP використовує 8 біт для позначення кількості червоного кольору в пікселі, 8 біт для позначення кількості зеленого в кольорі пікселя та 8 біт для позначення кількості синього в кольорі пікселя. Якщо ви коли-небудь чули про колір RGB, ось він у вас є: червоний, зелений, синій.

Якщо значення R, G і B деякого пікселя в BMP є, скажімо, `0xff`, `0x00` і `0x00` у шістнадцятковій системі, цей піксель є чисто червоним, як `0xff` (інакше відомий як «255» у десятковій системі) означає «багато червоного», тоді як `0x00` і `0x00` означають «немає зеленого» і «немає синього» відповідно.

### Біт (мапа)

Пам’ятайте, що файл – це лише послідовність бітів, упорядкованих певним чином. Отже, 24-бітний файл BMP — це, по суті, лише послідовність бітів, (майже) кожні 24 з яких представляють певний колір пікселя. Але файл BMP також містить деякі «метадані», інформацію, як-от висота та ширина зображення. Ці метадані зберігаються на початку файлу у формі двох структур даних, які зазвичай називаються «заголовками», не плутати з файлами заголовків C. (До речі, ці заголовки змінювалися з часом. Це завдання використовує останню версію формату Microsoft BMP, 4.0, який дебютував у Windows 95.)

Перший із цих заголовків, який називається `BITMAPFILEHEADER`, має довжину 14 байтів. (Пам’ятайте, що 1 байт дорівнює 8 бітам.) Другий із цих заголовків, який називається `BITMAPINFOHEADER`, має довжину 40 байтів. Відразу після цих заголовків розташовується растрове зображення: масив байтів, кожен третій з яких представляють колір пікселя. Однак BMP зберігає ці трійки в зворотному порядку (тобто як BGR), з 8 бітами для синього, потім 8 бітами для зеленого, потім 8 бітами для червоного. (Деякі BMP також зберігають все растрове зображення назад, із верхнім рядком зображення в кінці BMP-файлу. Але ми зберегли BMP цього набору проблем, як описано тут, з кожним верхнім рядком растрового зображення першим, а нижнім — останнім.) словами, якби ми перетворили 1-бітний смайлик вище на 24-бітний смайлик, замінивши червоний на чорний, 24-бітний BMP зберігав би це растрове зображення таким чином, де `0000ff` позначає червоний колір, а `ffffff` позначає білий; ми виділили червоним кольором усі випадки `0000ff`.

![alt text](https://cs50.harvard.edu/x/2023/psets/4/filter/less/red_smile.png)

Оскільки ми представили ці фрагменти зліва направо, зверху вниз у 8 стовпців, ви можете побачити червоний смайлик, якщо зробите крок назад від монітора.

Щоб було зрозуміло, нагадаємо, що шістнадцяткова цифра представляє 4 біти. Відповідно, `ffffff` у шістнадцятковому насправді означає `111111111111111111111111` у двійковому.

Зверніть увагу, що растрове зображення можна представити як двовимірний масив пікселів: де зображення є масивом рядків, кожен рядок є масивом пікселів. Саме так ми вирішили представити растрові зображення в цій задачі.

### [Фільтрування зображень](#image-filtering)

Що взагалі означає фільтрувати зображення? Ви можете думати про фільтрування зображення як про взяття пікселів якогось вихідного зображення та зміну кожного пікселя таким чином, щоб певний ефект був очевидним на отриманому зображенні.

#### Відтінки сірого

Одним із поширених фільтрів є фільтр «відтінки сірого», коли ми беремо зображення та хочемо перетворити його на чорно-біле. Як це працює?

Пам’ятайте, що якщо всі значення червоного, зеленого та синього мають значення «0x00» (шістнадцяткове для «0»), то піксель чорний. І якщо для всіх значень встановлено `0xff` (шістнадцяткове для `255`), то піксель буде білим. Поки всі значення червоного, зеленого та синього однакові, результатом будуть різні відтінки сірого уздовж чорно-білого спектру, причому вищі значення означатимуть світліші відтінки (ближче до білого), а нижчі значення означатимуть темніші відтінки (ближче до чорний).

Отже, щоб перетворити піксель у відтінки сірого, нам просто потрібно переконатися, що значення червоного, зеленого та синього мають однакове значення. Але як ми знаємо, яке значення їм присвоїти? Що ж, мабуть, розумно очікувати, що якщо вихідні значення червоного, зеленого та синього були досить високими, то нове значення також має бути досить високим. І якщо початкові значення були низькими, то нове значення також має бути низьким.

Фактично, щоб переконатися, що кожен піксель нового зображення все ще має таку ж загальну яскравість або темність, як і старе зображення, ми можемо взяти середнє значення червоного, зеленого та синього, щоб визначити, який відтінок сірого зробити для нового пікселя.

Якщо застосувати це до кожного пікселя на зображенні, результатом буде зображення, перетворене на відтінки сірого.

#### [Сепія](#сепія)

Більшість програм для редагування зображень підтримують фільтр «сепія», який надає зображенням відчуття старовини, роблячи все зображення трохи червонувато-коричневим.

Зображення можна перетворити на сепію, взявши кожен піксель і обчисливши нові значення червоного, зеленого та синього на основі вихідних значень трьох.

Існує кілька алгоритмів для перетворення зображення на сепію, але для вирішення цієї проблеми ми попросимо вас скористатися наступним алгоритмом. Для кожного пікселя значення кольору сепії слід обчислювати на основі вихідних значень кольору, як зазначено нижче.

       sepiaRed = .393 * оригінальний червоний + .769 * оригінальний зелений + .189 * оригінальний синій
       sepiaGreen = .349 * оригінальний червоний + .686 * оригінальний зелений + .168 * оригінальний синій
       sepiaBlue = .272 * оригінальний червоний + .534 * оригінальний зелений + .131 * оригінальний синій
    

Звичайно, результат кожної з цих формул може бути не цілим числом, але кожне значення можна округлити до найближчого цілого числа. Також можливо, що результатом формули буде число більше 255, максимальне значення для 8-бітного значення кольору. У цьому випадку значення червоного, зеленого та синього мають бути обмежені 255. У результаті ми можемо гарантувати, що отримані значення червоного, зеленого та синього будуть цілими числами від 0 до 255 включно.

#### [Дзеркальне відображення](#відображення)

Деякі фільтри також можуть переміщувати пікселі. Відображення зображення, наприклад, є фільтром, де отримане зображення є тим, що ви отримали б, розмістивши вихідне зображення перед дзеркалом. Таким чином, будь-які пікселі з лівого боку зображення повинні закінчуватися праворуч, і навпаки.

Зауважте, що всі оригінальні пікселі оригінального зображення все ще будуть присутні у відображеному зображенні, просто ці пікселі, можливо, переставили в інше місце на зображенні.

#### [Блюр](#розмиття)

Існує кілька способів створення ефекту розмиття або пом'якшення зображення. Для цієї проблеми ми використаємо «розмиття прямокутником», яке працює, беручи кожен піксель і для кожного значення кольору надаючи йому нове значення шляхом усереднення значень кольорів сусідніх пікселів.

Розглянемо наступну сітку пікселів, де ми пронумерували кожен піксель.

![сітка пікселів](https://cs50.harvard.edu/x/2023/psets/4/filter/less/grid.png)

Нове значення кожного пікселя буде середнім значень усіх пікселів, які знаходяться в межах 1 рядка та стовпця оригінального пікселя (утворюючи рамку 3x3). Наприклад, кожне зі значень кольору для пікселя 6 буде отримано шляхом усереднення початкових значень кольору пікселів 1, 2, 3, 5, 6, 7, 9, 10 і 11. Подібним чином значення кольорів для пікселя 11 можна отримати шляхом усереднення значень кольорів пікселів 6, 7, 8, 10, 11, 12, 14, 15 і 16.

Для пікселя вздовж краю або кута, наприклад пікселя 15, ми все одно шукатимемо всі пікселі в межах 1 рядка та стовпця: у цьому випадку пікселі 10, 11, 12, 14, 15 і 16.

[Початок роботи](#getting-started)
----------------------------------

Увійдіть у [cs50.dev](https://cs50.dev/), клацніть вікно терміналу та виконайте `cd`. Ви повинні побачити, що курсор вікна терміналу нагадує наведене нижче:

     $
    

Далі виконайте

     wget https://cdn.cs50.net/2022/fall/psets/4/filter-less.zip
    

щоб завантажити ZIP-файл під назвою `filter-less.zip` у ваш кодовий простір.

Потім виконайте

     unzip filter-less.zip
    

щоб створити папку під назвою `filter-less`. ZIP-файл вам більше не потрібен, тому ви можете виконати

     rm filter-less.zip
    

натисніть «y», а потім натисніть Enter у запиті, щоб видалити завантажений файл ZIP.

Тепер введіть

     cd filter-less
    

після чого натисніть Enter, щоб перемістити себе в (тобто відкрити) цю папку. Тепер ваш курсор має нагадувати наведене нижче.

     filter-less/ $
    

Виконайте `ls`, і ви побачите кілька файлів: `bmp.h`, `filter.c`, `helpers.h`, `helpers.c` і `Makefile`. Ви також повинні побачити папку під назвою `images` з чотирма файлами BMP. Якщо у вас виникли проблеми, виконайте ті самі дії ще раз і перевірте, чи зможете ви визначити, де ви помилилися!

[Розуміння](#розуміння)
------------------------------

Давайте тепер подивимося на деякі файли, надані вам як код розповсюдження, щоб зрозуміти, що в них міститься.

### [`bmp.h`](#bmph)

Відкрийте `bmp.h` (подвійним клацанням на ньому в браузері файлів) і подивіться.

Ви побачите визначення згаданих нами заголовків (`BITMAPINFOHEADER` і `BITMAPFILEHEADER`). Крім того, цей файл визначає типи даних `BYTE`, `DWORD`, `LONG` і `WORD`, які зазвичай зустрічаються у світі програмування Windows. Зверніть увагу, що це просто псевдоніми для примітивів, з якими ви (сподіваємося) вже знайомі. Схоже, що `BITMAPFILEHEADER` і `BITMAPINFOHEADER` використовують ці типи.

Можливо, найважливішим для вас є те, що цей файл також визначає `структуру` під назвою `RGBTRIPLE`, яка досить просто «інкапсулює» три байти: один синій, один зелений і один червоний.

Чим ці структури корисні? Пам’ятайте, що файл — це лише послідовність байтів (або, зрештою, бітів) на диску. Але ці байти зазвичай упорядковані таким чином, що перші кілька представляють щось, наступні представляють щось інше і так далі. «Формати файлів» існують тому, що світ стандартизував, що байти означають. Тепер ми можемо просто прочитати файл із диска в оперативну пам’ять як один великий масив байтів. І ми могли просто запам’ятати, що байт у `array[i]` представляє одне, тоді як байт у `array[j]` представляє інше. Але чому б не дати деяким із цих байтів назви, щоб ми могли легше отримати їх із пам’яті? Це саме те, що дозволяють нам робити структури в `bmp.h`. Замість того, щоб думати про якийсь файл як про одну довгу послідовність байтів, ми можемо думати про нього як про послідовність структур.

### [`filter.c`](#filterc)

Тепер давайте відкриємо `filter.c`. Цей файл уже був написаний для вас, але тут варто звернути увагу на кілька важливих моментів.

По-перше, зверніть увагу на визначення `filters` у рядку 10. Цей рядок повідомляє програмі, які дозволені аргументи командного рядка для програми: `b`, `g`, `r` і `s`. Кожен із них визначає інший фільтр, який ми можемо застосувати до наших зображень: розмиття, відтінки сірого, відображення та сепія.

Наступні кілька рядків відкривають файл зображення, перевіряють, що це справді файл BMP, і зчитують всю інформацію про пікселі в 2D-масив під назвою «зображення».

Прокрутіть униз до оператора `switch`, який починається в рядку 101. Зауважте, що залежно від того, який `filter` ми обрали, викликається інша функція: якщо користувач вибирає фільтр `b`, програма викликає функцію `blur`; якщо `g`, то викликається `grayscale`; якщо `r`, то викликається `reflect`; а якщо `s`, то викликається `sepia`. Також зауважте, що кожна з цих функцій приймає як аргументи висоту зображення, ширину зображення та двовимірний масив пікселів.

Це функції, які ви (незабаром!) запровадите. Як ви можете собі уявити, метою кожної з цих функцій є редагування двовимірного масиву пікселів таким чином, щоб до зображення було застосовано потрібний фільтр.

Решта рядків програми беруть отримане `зображення` і записують його в новий файл зображення.

### [`helpers.h`](#helpersh)

Далі подивіться на `helpers.h`. Цей файл досить короткий і містить лише прототипи функцій, які ви бачили раніше.

Тут зверніть увагу на той факт, що кожна функція приймає 2D-масив під назвою `image` як аргумент, де `image` — це масив `height` багатьох рядків, а кожен рядок сам є іншим масивом `width` багатьох `RGBTRIPLE `s. Отже, якщо `image` представляє всю картинку, то `image[0]` представляє перший рядок, а `image[0][0]` представляє піксель у верхньому лівому куті зображення.

### [`helpers.c`](#helpersc)

Тепер відкрийте `helpers.c`. Ось де належить реалізація функцій, оголошених у `helpers.h`. Але зауважте, що наразі реалізації відсутні! Ця частина залишається за вами.

### [`Makefile`](#makefile)

Нарешті, давайте подивимося на `Makefile`. Цей файл визначає, що має статися, коли ми виконуємо команду терміналу, наприклад `make filter`. У той час як програми, які ви, можливо, писали раніше, були обмежені лише одним файлом, `filter`, використовує кілька файлів: `filter.c` і `helpers.c`. Тому нам потрібно буде сказати `make`, як скомпілювати цей файл.

Спробуйте скомпілювати `filter`, перейшовши до свого терміналу та запустивши

     $ make filter
    

Потім ви можете запустити програму, виконавши:

     $ ./filter -g images/yard.bmp out.bmp
    

яка отримує зображення з `images/yard.bmp` і генерує нове зображення під назвою `out.bmp` після пропускання пікселів через функцію `grayscale`. Проте `grayscale` поки що нічого не робить, тому вихідне зображення має виглядати так само, як і вхідне.

[Специфікація](#специфікація)
------------------------------

Реалізуйте функції в `helpers.c`, щоб користувач міг застосовувати до своїх зображень фільтри відтінків сірого, сепії, відображення або розмиття.

* Функція `grayscale` має взяти зображення та перетворити його на чорно-білу версію того самого зображення.
* Функція `sepia` має взяти зображення та перетворити його на версію того самого зображення у сепії.
* Функція `reflect` має взяти зображення та відобразити його горизонтально.
* Нарешті, функція `blur` має взяти зображення та перетворити його на розмиту версію того самого зображення.

Вам не слід змінювати будь-які сигнатури функцій, а також не слід змінювати будь-які інші файли, крім `helpers.c`.

[Використання](#використання)
---------------

Ваша програма має поводитися як приклади нижче. `INFILE.bmp` — це ім’я вхідного зображення, а `OUTFILE.bmp` — це ім’я результуючого зображення після застосування фільтра.

     $ ./filter -g INFILE.bmp OUTFILE.bmp
    

     $ ./filter -s INFILE.bmp OUTFILE.bmp
    

     $ ./filter -r INFILE.bmp OUTFILE.bmp
    

     $ ./filter -b INFILE.bmp OUTFILE.bmp
    

[Підказки](#підказки)
---------------

* Значення піксельних компонентів `rgbtRed`, `rgbtGreen` і `rgbtBlue` є цілими числами, тому не забудьте округлити будь-які числа з плаваючою комою до найближчого цілого числа, призначаючи їх значенню пікселя!
* Під час реалізації функції «відтінки сірого» вам потрібно буде усереднити значення 3 цілих чисел. Чи варто вам поділити суму цих цілих чисел на 3.0, а не на 3?
* У функції `reflect` вам потрібно буде поміняти значення пікселів на протилежних сторонах рядка. Згадайте з лекції, як ми реалізували заміну двох значень за допомогою тимчасової змінної. Не потрібно використовувати окрему функцію для обміну, якщо ви цього не хочете!
* Як функція, яка повертає менше з двох цілих чисел, може бути корисною під час реалізації `sepia`, особливо коли вам потрібно переконатися, що значення кольору не перевищує 255?
* Під час реалізації функції `blur` ви можете виявити, що розмиття одного пікселя в кінцевому підсумку вплине на розмиття іншого пікселя. Можливо, створіть копію `image` (третій аргумент функції), оголосивши новий (двовимірний) масив із таким кодом, як `RGBTRIPLE copy[height][width];` і скопіювавши `image` у `copy`, піксель на піксель, із вкладеними циклами `for`? А потім прочитати кольори пікселів із `copy`, але записати (тобто змінити) кольори пікселів у `image`?

[Тестування](#testing)
-------------------

Перевірте всі свої фільтри на наданих зразках растрових файлів!

Виконайте наведені нижче дії, щоб оцінити правильність вашого коду за допомогою `check50`. Але обов’язково скомпілюйте та протестуйте його самостійно!

     check50 cs50/problems/2023/x/filter/less
    

Виконайте наведені нижче дії, щоб оцінити стиль вашого коду за допомогою `style50`.

     style50 helpers.c
