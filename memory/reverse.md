[Reverse](#реверс)
====================

Реалізуйте програму, яка повертає WAV-файл, як зазначено нижче.

     ./reverse input.wav output.wav
    

[Опис](#фон)
------------------------
https://www.youtube.com/embed/J9iyqMwYtG4

У композиції Electric Light Orchestra «Fire on High» є щось незначне в першій хвилині музики. Якщо ви послухаєте, це звучить майже так, ніби аудіо відтворюється назад. Як виявилося, якщо відтворити початкову частину пісні навпаки, ви почуєте наступне:

“The music is reversible. Time is not. Turn back, turn back!”

Моторошно, правда? Це техніка, яка називається «backmasking» або приховування повідомлень у музиці, які можна почути, лише коли пісня відтворюється назад. Багато виконавців використовували (або підозрювалися у використанні) цю техніку у своїх піснях. Щоб провести наше власне розслідування зворотної маски, ми попросили вас написати для нас програму, яка може перевертати файли WAV!

На відміну від аудіофайлів MP3, файли WAV не стискаються. Це значно полегшує редагування та маніпулювання файлами, що корисно для поставленого завдання. Щоб дізнатися більше про файли WAV, нам потрібно ближче розглянути формат файлу WAV.

[Початок роботи](#getting-started)
----------------------------------

Відкрийте [VS Code](https://cs50.dev/).

Почніть із клацання у вікні терміналу, потім виконайте `cd`. Ви побачите, що його курсор нагадує наведене нижче.

     $
    

Клацніть всередині цього вікна терміналу, а потім виконайте

     wget https://cdn.cs50.net/2022/fall/psets/4/reverse.zip
    

потім Enter, щоб завантажити ZIP-архів під назвою `reverse.zip` у ваш кодовий простір. Будьте обережні, щоб не пропустити пробіл між `wget` і наступною URL-адресою або будь-яким іншим символом, якщо на те пішло!

Тепер виконайте

     unzip reverse.zip
    

щоб створити папку під назвою `reverse`. ZIP-файл вам більше не потрібен, тому ви можете виконати

     rm reverse.zip
    

і натисніть «y», а потім натисніть Enter у запиті, щоб видалити завантажений файл ZIP.

Тепер введіть

     cd reverse
    

після чого натисніть Enter, щоб перемістити себе в (тобто відкрити) цю папку. Тепер ваш курсор має нагадувати наведене нижче.

     reverse/ $
    

Якщо все пройшло успішно, слід виконати

     ls
    

і перегляньте файл з назвою `reverse.c`. Виконайте `code reverse.c` що відкриє файл, у який ви введете свій код для цього набору проблем. Якщо ні, повторіть свої кроки та подивіться, чи зможете ви визначити, де ви помилилися!

### [Формат файлу WAV](#the-wav-file-format)

Зверніть увагу, що на зображенні нижче файл WAV розбитий на три частини. Кожна послідовність містить кілька блоків даних.

Перший фрагмент містить інформацію про тип файлу. Зокрема, подивіться, як у блоці «Формат файлу» в першому фрагменті в байтах 8–11 викладено «W», «A», «V» «E», щоб вказати, що файл є файлом WAV.

Другий фрагмент містить інформацію про майбутні аудіодані, включаючи кількість присутніх «каналів» аудіо та кількість бітів у кожному «зразку» аудіо. Аудіофайли мають 1 канал, коли вони «монофонічні»: якби ви одягли навушники, ви почули б однаковий звук у лівому та правому вусі. Аудіофайли мають 2 канали, коли вони «стереофонічні»: у навушниках ви почуєте дещо різний звук у лівому та правому вусі, створюючи відчуття простору. Семпли — це окремі фрагменти бітів, які складають звук, який ви чуєте. Завдяки більшій кількості бітів на вибірку аудіофайл може мати більшу чіткість (за рахунок використання більшої пам’яті!).

Нарешті, третій фрагмент містить самі аудіодані — ті зразки, про які ми згадували вище.

Усе, що передує звуковим даним, вважається частиною «заголовка» WAV. Пам’ятайте, що заголовок файлу – це просто деякі метадані про файл. У цьому випадку заголовок має довжину 44 байти.

![Заголовок WAV](https://cs50.harvard.edu/x/2023/psets/4/reverse/WAV_header.png)

Детальніше технічне пояснення заголовків WAV можна знайти [тут](http://soundfile.sapp.org/doc/WaveFormat/), який є джерелом натхнення для цього візуалізації. Зверніть увагу, що ми включили файл `wav.h`, який реалізує всі ці деталі для вас у структурі під назвою `WAVHEADER`.

[Специфікація](#специфікація)
------------------------------

Давайте напишемо програму під назвою `reverse`, яка дає нам змогу реверсувати WAV-файл, наданий користувачем, і створювати новий WAV-файл, який містить отримане реверсоване аудіо. Для простоти ми обмежимо файли, з якими маємо справу, до формату WAV. У той час, коли користувач виконує програму, він повинен надати, використовуючи два аргументи командного рядка, назву вхідного файлу, який потрібно прочитати та перевернути, і назву вихідного файлу, у якому він хоче зберегти результуюче аудіо. Успішно виконана програма не повинна виводити жодного тексту та повинна створити файл WAV із вказаною користувачем назвою, який відтворює аудіо вхідного файлу WAV у зворотному порядку. Наприклад:

     $ ./reverse input.wav output.wav
    

У `reverse.c` ви помітите, що включено кілька корисних бібліотек, а також файл заголовка `wav.h`. Ймовірно, ви знайдете це корисним під час реалізації своєї програми. Ми залишили вісім завдань і дві допоміжні функції, які ви можете заповнити, і ми рекомендуємо вам виконувати їх у порядку від 1 до 8.

* У першому `TODO` ви повинні переконатися, що програма приймає два аргументи командного рядка: ім’я вхідного WAV-файлу та ім’я вихідного WAV-файлу. Якщо програма не відповідає цим умовам, ви повинні надрукувати відповідне повідомлення про помилку та повернути `1`, завершуючи програму.
     * Підказка
        
         * Майте на увазі, що кількість аргументів командного рядка можна знайти в змінних `argc`, які передаються до функції `main` під час виконання програми.
         * Пам’ятайте, що `argv[0]` містить назву програми як перший аргумент командного рядка.
        
* У другому `TODO` вам слід відкрити вхідний файл. Нам потрібно буде відкрити вхідний файл у режимі «тільки для читання», оскільки ми будемо лише читати дані з вхідного файлу. Можливо, доцільно перевірити, чи успішно відкрито файл. В іншому випадку ви повинні надрукувати відповідне повідомлення про помилку та повернути `1`, виходячи з програми. Однак нам слід затриматися з відкриттям вихідного файлу, щоб не створити новий WAV-файл, не дізнавшись, що вхідний файл дійсний!
     * Підказка
        
         * Якщо перше `TODO` було реалізовано належним чином, можна з упевненістю припустити, що ми можемо посилатися на назву вхідного файлу за допомогою `argv[1]`.
         * Майте на увазі, будь-який файл, який ми відкриваємо, ми також повинні закрити, коли закінчимо його використовувати. Це може означати додавання коду в іншу частину програми.
        
* У третьому `TODO` вам слід прочитати заголовок із вхідного файлу. Нагадаємо, що в `wav.h` ми вже реалізували структуру, яка може зберігати заголовок файлу WAV. Оскільки ми написали `#include "wav.h"` у верхній частині `reverse.c`, ви також можете використовувати структуру `WAVHEADER`.
    
* У четвертому `TODO` ви повинні виконати функцію `check_format`. `check_format` приймає один аргумент, `WAVHEADER`, який називається `header`, представляючи структуру, що містить заголовок вхідного файлу. Якщо `header` вказує, що файл справді є файлом WAV, функція `check_format` має повернути `true`. Якщо ні, `check_format` має повернути `false`. Щоб перевірити, чи має файл формат WAV, ми можемо порівняти елементи заголовка вхідного файлу з тими, які ми очікуємо від файлу WAV. Досить показати, що символи маркера «WAVE» знаходяться в члені `format` структури `WAVHEADER` (див. [Background](#background) для отримання додаткової інформації про заголовки файлів WAV).
    
* У п’ятому `TODO` тепер ви можете безпечно відкрити вихідний файл для запису. Все одно було б розумно перевірити, чи успішно відкрито файл.
     * Підказки
        
         * Якщо перше `TODO` було реалізовано належним чином, можна з упевненістю припустити, що ми можемо посилатися на назву вихідного файлу за допомогою `argv[2]`.
         * Майте на увазі, будь-який файл, який ми відкриваємо, ми також повинні закрити, коли закінчимо його використовувати. Це може означати додавання коду в іншу частину програми.
        

Це може бути хорошим місцем, щоб зупинитися та перевірити, чи ваша програма поводиться належним чином. Якщо реалізовано належним чином, ваша програма має відкрити новий файл під час виконання з належними аргументами командного рядка.

Якщо в будь-який момент ви вважаєте за потрібне видалити файл, виконайте наступну команду в поточному робочому каталозі.

     $ rm ім'я_файлу.wav
    

Якщо ви не хочете підтверджувати кожне видалення, замість цього виконайте наведену нижче команду.

     $ rm -f ім'я_файлу.wav
    

Просто будьте обережні з перемикачем `-f`, оскільки він «примусово» видаляє без підказки.

* Далі, тепер, коли тип файлу було перевірено, шосте `TODO` говорить нам записати заголовок у вихідний файл. Перевернутий файл WAV все ще матиме таку саму базову файлову структуру, як і вхідний файл (такий самий розмір, кількість каналів, біт на вибірку тощо), тому достатньо скопіювати заголовок, який ми читаємо з вхідного файлу у третьому ` TODO` у вихідний файл.
    
* У сьомому `TODO` вам слід реалізувати функцію `get_block_size`. `get_block_size`, як і `check_format`, приймає один аргумент: це `WAVHEADER`, який називається `header`, представляючи структуру, що містить заголовок вхідного файлу. `get_block_size` має повертати ціле число, що представляє **розмір блоку** даного файлу WAV у байтах. Ми можемо думати про _блок_ як про одиницю звукових даних. Для аудіо ми обчислюємо розмір кожного блоку за допомогою такого розрахунку: **кількість каналів**, помножена на **байт на вибірку**. На щастя, заголовок містить всю інформацію, необхідну для обчислення цих значень. Обов’язково зверніться до розділу [Background](#background), щоб отримати детальніші пояснення щодо значення цих значень і способів їх зберігання. Перегляньте також `wav.h`, щоб визначити, які члени `WAVHEADER` можуть бути корисними.
* Підказки
    
     * Зверніть увагу, що одним із членів `WAVHEADER` є `bitsPerSample`. Але щоб обчислити розмір блоку, вам знадобиться **байт** на вибірку!
    
* Восьмий і останній `TODO` - це місце, де фактично відбувається реверс аудіо. Для цього нам потрібно прочитати в кожному блоці звукові дані, починаючи з самого кінця вхідного файлу і рухаючись назад, одночасно записуючи кожен блок у вихідний файл, щоб вони записувалися у зворотному порядку. По-перше, ми повинні оголосити масив для зберігання кожного блоку, який ми зчитуємо. Потім ви повинні переглянути аудіодані вхідного файлу. Будьте впевнені, що ви прочитали весь аудіофайл, але не копіюйте помилково дані із заголовка! Крім того, з метою тестування ми хотіли б зберегти порядок каналів для кожного аудіоблоку. Наприклад, у файлі WAV із двома каналами (стереофонічний звук) ми хочемо переконатися, що перший канал останнього аудіоблоку на вході стає першим каналом першого аудіоблоку на виході.
* Підказки
    
     * Кілька функцій (і глибоке розуміння їх використання) можуть бути особливо корисними під час заповнення цього розділу - сторінки посібника CS50 можуть виявитися особливо корисними тут:
         * [`fread`](https://manual.cs50.io/3/fread): читає з файлу в буфер. Вихід допоміжної функції `get_block_size` може бути корисним тут, коли вирішуєте, які значення використовувати для розміру та кількості даних, які читаються одночасно.
         * [`fwrite`](https://manual.cs50.io/3/fwrite): записує з буфера у файл.
         * [`fseek`](https://manual.cs50.io/3/fseek): встановлює покажчик файлу на вказане зміщення. Може бути корисно поекспериментувати з від’ємними значеннями зсуву, щоб перемістити покажчик файлу назад.
         * [`ftell`](https://manual.cs50.io/3/ftell): повертає поточну позицію покажчика файлу. Може бути корисно перевірити, яке значення `ftell` повертає після того, як вхідний заголовок прочитано в третьому `TODO`, на додаток до того, яке воно повертає під час зчитування аудіоданих.
     * Майте на увазі, що після того, як ви використовуєте `fread` для завантаження блоку даних, покажчик `input` вказуватиме на місце, де завершено читання. Іншими словами, вказівник `input` може знадобитися перемістити назад на _два_ розміри блоку після кожного `fread`, один, щоб повернутися до місця початку `fread`, а другий, щоб перейти до попереднього, непрочитаного блоку.
    
* Нарешті, обов’язково закрийте всі файли, які ви відкривали!

[Використання](#використання)
---------------

Ось кілька прикладів того, як має працювати програма. Наприклад, якщо користувач пропускає один із аргументів командного рядка:

     $ ./reverse input.wav
     Usage: ./reverse input.wav output.wav
    

Або якщо користувач пропускає обидва параметри командного рядка:

     $ ./reverse
     Usage: ./reverse input.wav output.wav
    

Ось як програма має працювати, якщо користувач надає вхідний файл, який не є фактичним файлом WAV:

     $ ./reverse image.jpg output.wav
     Input is not a WAV file.
    

Ви можете припустити, що користувач вводить дійсну назву вихідного файлу, наприклад `output.wav`.

Успішно виконана програма не повинна виводити жодного тексту та повинна створити файл WAV із вказаною користувачем назвою, який відтворює аудіо вхідного файлу WAV у зворотному порядку. Наприклад:

     $ ./reverse input.wav output.wav
    

[Тестування](#testing)
-------------------

Виконайте наведені нижче дії, щоб оцінити правильність вашого коду за допомогою `check50`. Але обов’язково скомпілюйте та протестуйте його самостійно!

     check50 cs50/problems/2023/x/реверс
    

Виконайте наведені нижче дії, щоб оцінити стиль вашого коду за допомогою `style50`.

     style50 reverse.c
