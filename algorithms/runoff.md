[Вибори](#стік)
==================

Для цього завдання ви запровадите програму, яка проводить другий тур виборів, як зазначено нижче.

     ./runoff Alice Bob Charlie
     Number of voters: 5
     Rank 1: Alice
     Rank 2: Bob
     Rank 3: Charlie

     Rank 1: Alice
     Rank 2: Charlie
     Rank 3: Bob

     Rank 1: Bob
     Rank 2: Charlie
     Rank 3: Alice

     Rank 1: Bob
     Rank 2: Alice
     Rank 3: Charlie

     Rank 1: Charlie
     Rank 2: Alice
     Rank 3: Bob

     Alice
    

#Опис
------------------------

Ви вже знаєте про мажоритарні вибори, які відбуваються за дуже простим алгоритмом визначення переможця виборів: кожен виборець отримує один голос, і перемагає кандидат, який набрав найбільшу кількість голосів.

Але мажоритарне голосування має деякі недоліки. Що відбувається, наприклад, на виборах із трьома кандидатами, і подано подані нижче бюлетені?

![П’ять бюлетенів, рівність між Алісою та Бобом](https://cs50.harvard.edu/x/2023/psets/3/fptp_ballot_1.png)

Більшість голосів тут оголосить нічию між Алісою та Бобом, оскільки кожен має два голоси. Але чи це правильний результат?

Існує інший вид системи голосування, відомий як система рейтингового голосування. У системі рейтингового вибору виборці можуть голосувати більше ніж за одного кандидата. Замість того, щоб просто голосувати за свій найкращий вибір, вони можуть ранжувати кандидатів у порядку переваги. Отримані бюлетені можуть виглядати так, як показано нижче.

![Три бюлетені з рейтинговими перевагами](https://cs50.harvard.edu/x/2023/psets/3/ranked_ballot_1.png)

Тут кожен виборець, окрім визначення першого кандидата, який йому більше подобається, також вказав другий і третій вибір. І тепер вибори, які раніше були нічийними, тепер можуть мати переможця. Спочатку гонка була рівною між Алісою та Бобом, тож Чарлі не брав участі. Але виборець, який вибрав Чарлі, віддав перевагу Алісі, а не Бобу, тому Алісу тут можна було оголосити переможцем.

Рейтингове голосування також може вирішити ще один потенційний недолік мажоритарного голосування. Подивіться на наступні бюлетені.

![Дев'ять бюлетенів із рейтинговими перевагами](https://cs50.harvard.edu/x/2023/psets/3/ranked_ballot_3.png)

Хто має виграти ці вибори? Під час голосування за системою більшості, коли кожен виборець обирає лише першого кандидата, Чарлі виграє ці вибори з чотирма голосами порівняно з трьома для Боба та двома для Аліси. Але більшість виборців (5 із 9) були б щасливішими за Алісу чи Боба замість Чарлі. Враховуючи ранжовані переваги, система голосування може вибрати переможця, який краще відображає переваги виборців.

Однією з таких систем рейтингового голосування є система миттєвого повторного голосування. У миттєвому другому турі виборів виборці можуть ранжувати скільки завгодно кандидатів. Якщо будь-який кандидат має більшість (понад 50%) голосів першого преференції, цей кандидат оголошується переможцем виборів.

Якщо жоден з кандидатів не набирає більше 50% голосів, то відбувається «миттєвий другий тур». Кандидат, який набрав найменшу кількість голосів, виключається з виборів, і кожен, хто спочатку обрав цього кандидата як першу перевагу, тепер враховує свою другу перевагу. Чому так? По суті, це імітує те, що сталося б, якби найменш популярний кандидат не брав участі у виборах.

Процес повторюється: якщо жоден кандидат не має більшості голосів, кандидат, який зайняв останнє місце, виключається, і будь-хто, хто проголосував за нього, натомість голосуватиме за свого наступного вподобання (який сам ще не був виключений). Коли кандидат отримує більшість, він оголошується переможцем.

Давайте розглянемо наведені вище дев’ять бюлетенів і розглянемо, як відбуватиметься другий тур виборів.

Аліса має два голоси, Боб має три голоси, а Чарлі має чотири голоси. Для перемоги на виборах з дев'ятьма особами потрібна більшість (п'ять голосів). Оскільки ніхто не має більшості, потрібно провести другий тур. Аліса має найменшу кількість голосів (лише два), тому Аліса вибуває. Виборці, які спочатку проголосували за Алісу, вказали Боба як другий варіант, тому Боб отримує додаткові два голоси. Зараз у Боба п’ять голосів, у Чарлі – чотири. Тепер Боб має більшість, і Боба оголошено переможцем.

Які випадки нам тут потрібно розглянути?

Одна з можливостей полягає в тому, що існує нічия для того, хто повинен бути усунений. Ми можемо вирішити цей сценарій, сказавши, що всі кандидати, які займають останнє місце, будуть виключені. Однак, якщо всі кандидати, що залишилися, мають однакову кількість голосів, виключення кандидатів, які посіли останні місця, означає виключення всіх! Тож у такому випадку нам доведеться бути обережними, щоб не виключити всіх і просто оголосити вибори рівними між усіма кандидатами, що залишилися.

Деякі миттєві вибори не вимагають від виборців ранжувати всі свої вподобання, тому на виборах може бути п’ять кандидатів, але виборець може обрати лише двох. Однак для цілей цієї проблеми ми проігноруємо цей випадок і припустимо, що всі vінші ранжуватимуть усіх кандидатів у бажаному порядку.

Звучить дещо складніше, ніж мажоритарне голосування, чи не так? Але, мабуть, воно має переваги, оскільки є виборчою системою, де переможець виборів точніше представляє переваги виборців.

[Початок роботи](#getting-started)
----------------------------------

Увійдіть у [cs50.dev](https://cs50.dev/), клацніть вікно терміналу та виконайте `cd` самостійно. Ви повинні побачити, що підказка вікна терміналу нагадує наведене нижче:

     $
    

Далі виконати

     wget https://cdn.cs50.net/2022/fall/psets/3/runoff.zip
    

щоб завантажити ZIP-архів під назвою `runoff.zip` у ваш кодовий простір.

Потім виконайте

     unzip runoff.zip
    

щоб створити папку під назвою `runoff`. ZIP-файл вам більше не потрібен, тому ви можете виконати

     rm runoff.zip
    

і відповідайте «y», а потім натисніть Enter у запиті, щоб видалити завантажений файл ZIP.

Тепер введіть

     cd runoff
    

після чого натисніть Enter, щоб перемістити себе в (тобто відкрити) цей каталог. Тепер ваша підказка має нагадувати наведене нижче.

     runoff/ $
    

Якщо все пройшло успішно, слід виконувати

     ls
    

і перегляньте файл під назвою `runoff.c`. Виконання `code runoff.c` має відкрити файл, у який ви введете свій код для цього завдання. Якщо ні, повторіть свої кроки та подивіться, чи зможете ви визначити, де ви помилилися!

[Розуміння](#розуміння)
------------------------------

Давайте подивимося на `runoff.c`. Ми створимо дві константи: `MAX_CANDIDATES` для максимальної кількості кандидатів на виборах і `MAX_VOTERS` для максимальної кількості виборців на виборах.

Далі йде двовимірний масив `preferences`. Масив `preferences[i]` представлятиме всі варіанти для виборця з номером `i`, а int `preferences[i][j]` зберігатиме індекс кандидата, який є `j`-м варіантом для виборець `i`.

Далі йде `struct` під назвою `candidate`. Кожен `candidate` має поле `string` для свого `name` та `int`, що представляє кількість `votes`, які він має на даний момент, і `bool` значення, яке називається `eliminated`, яке вказує, чи був кандидат виключений з виборів. Масив "candidates" відстежуватиме всіх кандидатів на виборах.

Програма також має дві глобальні змінні: `voter_count` і `candidate_count`.

Тепер перейдемо до `main`. Зауважте, що після визначення кількості кандидатів і кількості виборців починається основний цикл голосування, у якому кожен виборець має можливість проголосувати. Коли виборець вводить свої вподобання, викликається функція `vote`, щоб записати всі вподобання. Якщо в будь-який момент бюлетень визнається недійсним, програма завершує роботу.

Коли всі голоси подані, починається інший цикл: цей цикл продовжуватиме повторювати процес перевірки переможця та вилучення кандидата, який зайняв останнє місце, доки не буде переможця.

Першою викликається функція під назвою `tabulate`, яка має розглядати всі вподобання виборців і обчислювати поточні загальні результати голосування, дивлячись на першрго кандидата кожного виборця, який ще не вибув. Далі функція `print_winner` має вивести переможця, якщо він є; якщо є, програма закінчена. Але в іншому випадку програмі потрібно визначити найменшу кількість голосів, отриманих будь-яким учасником виборів (за допомогою функції `find_min`). Якщо виявляється, що всі учасники виборів мають однакову кількість голосів (як визначено функцією `is_tie`), вибори оголошуються рівними; інакше кандидат (або кандидати), що зайняв останнє місце, виключається з виборів через виклик функції `eliminate`.

Якщо ви подивитесь у файл трохи нижче, ви побачите, що функції — `vote`, `tabulate`, `print_winner`, `find_min`, `is_tie` і `eliminate` — є вашим завданням!

[Специфікація](#специфікація)
------------------------------

Завершіть реалізацію `runoff.c` таким чином, щоб він імітував вибори. Ви повинні завершити реалізацію функцій `vote`, `tabulate`, `print_winner`, `find_min`, `is_tie` і `eliminate`, і ви не повинні змінювати нічого іншого в `runoff.c` (і включення додаткових файлів заголовків, якщо бажаєте).

### [`vote`](#голосувати)

Виконайте функцію `vote`.

* Функція приймає аргументи `voter`, `rank` та `name`. Якщо `name` збігається з іменем дійсного кандидата, тоді вам слід оновити масив голосів, щоб вказати, що виборець `voter` має цього кандидата на місці `rank` (де `0` є першим уподобанням, `1` - другим, тощо).
* Якщо голос успішно записано, функція має повернути `true`; інакше функція має повернути `false` (якщо, наприклад, `name` не є іменем одного з кандидатів).
* Ви можете припустити, що немає двох кандидатів з однаковими іменами.

Підказки

* Нагадуємо, що `candidate_count` зберігає кількість кандидатів на виборах.
* Пам'ятайте, що ви можетевикористовуйте [`strcmp`](https://man.cs50.io/3/strcmp), щоб порівняти два рядки.
* Пам’ятайте, що `preferences[i][j]` зберігає індекс кандидата, який є `j`-им за рейтингом уподобань для `i`-го виборця.

### [`tabulate`](#tabulate)

Виконайте функцію `tabulate`.

* Функція має оновлювати кількість «голосів» кожного кандидата на цьому етапі виборів.
* Нагадуємо, що на кожному етапі виборів кожен виборець фактично голосує за свого кандидата, який йому найбільше подобається, але який ще не вибув.

Підказки

* Згадайте, що `voter_count` зберігає кількість виборців на виборах і що для кожного виборця на наших виборах ми хочемо підрахувати один бюлетень.
* Пам’ятайте, що для виборця `i` його найулюбленіший кандидат представлено `preferences[i][0]`, кандидат другого найулюбленіший — `preferences[i][1]` тощо.
* Пам’ятайте, що struct `candidate` має поле під назвою `eliminated`, яке буде `true`, якщо кандидата було виключено з виборів.
* Пам’ятайте, що struct `candidate` має поле під назвою `votes`, яке ви, імовірно, захочете оновити для кожного кандидата, якому виборець віддає перевагу.
* Після того, як ви проголосували за першого кандидата виборця, який не вибув, ви захочете зупинитися на досягнутому, а не продовжувати голосування! Пам’ятайте, що ви можете зупинити виконання циклу, використовуючи `break` всередині умови.

### [`print_winner`](#print_winner)

Виконайте функцію print_winner.

* Якщо будь-який кандидат має більше половини голосів, його ім’я має бути надруковано, а функція має повернути `true`.
* Якщо ще ніхто не виграв вибори, функція має повернути `false`.

Підказки

* Нагадуємо, що `voter_count` зберігає кількість виборців на виборах. Враховуючи це, як би ви виразили кількість голосів, необхідну для перемоги на виборах?

### [`find_min`](#find_min)

Виконайте функцію `find_min`.

* Функція має повертати мінімальну загальну кількість голосів для будь-якого кандидата, який ще бере участь у виборах.

Підказки

* Ймовірно, ви захочете переглянути кандидатів, щоб знайти того, хто все ще бере участь у виборах і має найменшу кількість голосів. Яку інформацію слід відстежувати, переглядаючи кандидатів?

### [`is_tie`](#is_tie)

Виконайте функцію `is_tie`.

* Функція приймає аргумент `min`, який буде мінімальною кількістю голосів, яку наразі має будь-хто на виборах.
* Функція має повертати `true`, якщо кожен кандидат, що залишився на виборах, має однакову кількість голосів, і повинна повертати `false` в іншому випадку.

Підказки

* Нагадуємо, що нічия буває, якщо кожен кандидат, який ще бере участь у виборах, має однакову кількість голосів. Зауважте також, що функція `is_tie` приймає аргумент `min`, який є найменшою кількістю голосів, яку зараз має будь-який кандидат. Як ви можете використати цю інформацію, щоб визначити, чи вибори є нічийними (або навпаки)?

### [`eliminate `](#усунути)

Виконайте функцію `eliminate`.

* Функція приймає аргумент `min`, який буде мінімальною кількістю голосів, яку наразі має будь-хто на виборах.
* Функція має виключити кандидата (або кандидатів), які мають `min` кількість голосів.

---------------------------

[Використання](#використання)
---------------

Ваша програма повинна працювати відповідно до прикладу нижче:

     ./runoff Alice Bob Charlie
     Number of voters: 5
     Rank 1: Alice
     Rank 2: Charlie
     Rank 3: Bob

     Rank 1: Alice
     Rank 2: Charlie
     Rank 3: Bob

     Rank 1: Bob
     Rank 2: Charlie
     Rank 3: Alice

     Rank 1: Bob
     Rank 2: Charlie
     Rank 3: Alice

     Rank 1: Charlie
     Rank 2: Alice
     Rank 3: Bob

     Alice
    

[Тестування](#testing)
-------------------

Обов’язково протестуйте свій код, щоб переконатися, що він обробляє…

* Вибори з будь-якою кількістю кандидатів (до `MAX` `9`)
* Голосування за кандидата по імені
* Недійсні голоси для кандидатів, яких немає в бюлетенях
* Друк переможця виборів, якщо є лише один
* Нікого не виключати у випадку рівності між усіма іншими кандидатами

Виконайте наведені нижче дії, щоб оцінити правильність вашого коду за допомогою `check50`. Але обов’язково скомпілюйте та протестуйте його самостійно!

     check50 cs50/problems/2023/x/runoff
    

Виконайте наведені нижче дії, щоб оцінити стиль вашого коду за допомогою `style50`.

     style50 runoff.c
