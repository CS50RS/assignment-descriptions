# Готівка

Відкрийте [VS Code](https://cs50.dev/).

Почніть, клікнувши всередині вашого терміналу, а потім виконайте `cd` без параметрів. Ви повинні побачити, що ваш "курсор" виглядає так:

```bash
$
```

Клікніть всередині цього термінального вікна, а потім виконайте

```bash
wget https://cdn.cs50.net/2022/fall/psets/1/cash.zip
```

і натисніть Enter, щоб завантажити ZIP-файл з назвою `cash.zip` у ваш кодспейс. Пам'ятайте, щоб не пропустити пробіл між `wget` і наступною URL-адресою чи будь-яким іншим символом!

Тепер виконайте

```bash
unzip cash.zip
```

щоб створити папку з назвою `cash`. Вам більше не потрібний ZIP-файл, тому можете виконати

```bash
rm cash.zip
```

і відповісти "y", а потім Enter на підтвердження видалення завантаженого ZIP-файлу.

Тепер введіть

```bash
cd cash
```

і натисніть Enter, щоб перейти (відкрити) до цієї папки. Ваш "курсор" тепер має вигляд:

```bash
cash/ $
```

Якщо все пройшло успішно, ви можете виконати

```bash
ls
```

і побачити файл з назвою `cash.c`. Виконання `code cash.c` відкриє файл, де ви будете вводити свій код для цього набору завдань. Якщо ні, повторіть свої кроки і перевірте, де ви помилились!

## Жадібні алгоритми

При розмінюванні коштів, імовірно, ви хочете мінімізувати кількість монет, які ви видаєте для кожного клієнта, щоб не залишитися без них (або не рознервувати клієнта!). На щастя, наука про комп'ютери дала касирам по всьому світу спосіб мінімізувати кількість монет, які вони повинні видавати: жадібні алгоритми.

За даними Національного інституту стандартів та технологій (NIST), жадібний алгоритм - це "алгоритм, який завжди обирає найкращий негайний або локальний розв'язок при пошуку відповіді. Жадібні алгоритми знаходять загальний або глобальний оптимальний розв'язок для деяких задач оптимізації, але можуть знаходити менш оптимальні розв'язки для деяких екземплярів інших задач."

Що це означає? Припустимо, що касир повинен видачу клієнту деяку суму решти, а в його касі є чверті (25 ¢), десятки (10 ¢), п'ятаки (5 ¢) і пенні (1 ¢). Проблема, яку потрібно вирішити, полягає у визначенні, які монети і скільки з них видати клієнту. Уявіть собі "жадібного" касира, який хоче відкусити якнайбільший шматок з цієї проблеми з кожною монетою, яку він бере з ящика. Наприклад, якщо клієнту потрібно дати на здачу 41 ¢, найбільший перший (тобто найкращий негайний або локальний) шматок, який може бути зроблений - 25 ¢. (Цей шматок є "найкращим", оскільки він швидше призводить нас до 0 ¢, ніж будь-яка інша монета.) Зверніть увагу, що шматок такого розміру зменшить проблему на 41 - 25 = 16 ¢. Це означає, що залишок є аналогічною, але меншою проблемою. Звісно, інший шматок в 25 ¢ був би занадто великим (припускаючи, що касир не хоче втрачати гроші), тому наш жадібний касир перейде до шматка розміром в 10 ¢, залишивши собі проблему в 6 ¢. На цьому етапі жадібність вимагає одного шматка розміром в 5 ¢ і одного шматка розміром в 1 ¢, після чого проблема вирішується. Клієнт отримує одну чверть, одну десятку, один п'ятак і один пенні - чотири монети в загальній кількості.

Виявляється, що цей жадібний підхід (тобто алгоритм) є не тільки локально оптимальним, але і глобально таким для валюти Америки (а також Європейського Союзу). Це означає, що за умови, що у касира є достатня кількість кожної монети, такий підхід від найбільшої до найменшої приведе до найменшої кількості монет. Наскільки мало? А це ви мені маєте сказати!

## Деталі реалізації

У файлі `cash.c` ми вже реалізували більшість (але не всю!) програми, яка запитує користувача про кількість центів, які треба видати як здачу, і потім друкує найменшу кількість монет, з якої можна скласти цю решту. Зокрема, функція `main` вже реалізована за вас. Але зверніть увагу, як `main` викликає декілька функцій, які ще не реалізовані! Одна з цих функцій, `get_cents`, не приймає аргументів (як вказано `void`) і повертає значення типу `int`. Решту функцій також приймають один аргумент типу `int` і також повертають значення типу `int`. Всі вони зараз повертають `0`, щоб код можна було скомпілювати. Вам треба замінити всі `TODO` і `return 0;` на свій власний код. Зокрема, завершіть реалізацію цих функцій наступним чином:

- `get_cents`: реалізуйте функцію таким чином, щоб вона запитувала користувача про кількість центів за допомогою `get_int` і повертала це число як `int`. Якщо користувач вводить від'ємне число, ваш код повинен знову запитати користувача. (Але вам не потрібно турбуватися про введення користувача, наприклад, слова, оскільки `get_int` впорається з цим за вас.) Імовірно, вам знадобиться цикл `do while`, такий як у `mario.c`!

- `calculate_quarters`: реалізуйте функцію таким чином, щоб вона обчислювала (і повертала як `int`), скільки чвертей має отримати клієнт, якщо йому боргують деяку кількість центів. Наприклад, якщо `cents` дорівнює `25`, тоді `calculate_quarters` має повернути `1`. Якщо `cents` дорівнює `26` або `49` (або будь-яке число між ними), то `calculate_quarters` також має повернути `1`. Якщо `cents` дорівнює `50` або `74` (або будь-яке число між ними), то `calculate_quarters` має повернути `2`. І так далі.

- `calculate_dimes`: реалізуйте функцію, яка обчислює те ж саме для десяток.

- `calculate_nickels`: реалізуйте функцію, яка обчислює те ж саме для п'ятаків.

- `calculate_pennies`: реалізуйте функцію, яка обчислює те ж саме для пенні.

Зверніть увагу, що, на відміну від функцій, які мають лише побічні ефекти, функції, які повертають значення, повинні робити це явно за допомогою `return`! Будьте уважні і не змінюйте сам розподільний

 код, замінюйте тільки дані `TODO` і значення, що повертаються!

Також зверніть увагу, що, нагадуючи про ідею абстракції, кожна з ваших функцій `calculate` повинна приймати будь-яке значення `cents`, а не тільки ті значення, які може запропонувати жадібний алгоритм. Наприклад, якщо `cents` дорівнює `85`, `calculate_dimes` повинна повернути `8`.

<details><summary>Підказка</summary><ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-square"></i></span>Пам'ятайте, що є кілька прикладів програм у <a href="https://cdn.cs50.net/2022/fall/lectures/1/src1/">вихідному коді</a> Week 1, які ілюструють, як функції можуть повертати значення.</li>
</ul></details>

Ваша програма повинна працювати так, як показано в прикладах нижче.

```plaintext
$ ./cash
Change owed: 41
4
```

```plaintext
$ ./cash
Change owed: -41
Change owed: foo
Change owed: 41
4
```

## Як перевірити свій код

Для цієї програми спробуйте тестувати свій код вручну - це хороша практика:

- Якщо ви вводите `-1`, чи ваша програма просить вас знову?
- Якщо ви вводите `0`, чи ваша програма виводить `0`?
- Якщо ви вводите `1`, чи ваша програма виводить `1` (тобто один пенні)?
- Якщо ви вводите `4`, чи ваша програма виводить `4` (тобто чотири пенні)?
- Якщо ви вводите `5`, чи ваша програма виводить `1` (тобто один п'ятак)?
- Якщо ви вводите `24`, чи ваша програма виводить `6` (тобто дві десятки і чотири пенні)?
- Якщо ви вводите `25`, чи ваша програма виводить `1` (тобто одну чверть)?
- Якщо ви вводите `26`, чи ваша програма виводить `2` (тобто одну чверть і один пенні)?
- Якщо ви вводите `99`, чи ваша програма виводить `9` (тобто три чверті, дві десятки і чотири пенні)?

Ви також можете виконати команду нижче, щоб перевірити правильність вашого коду за допомогою `check50`. Проте, обов'язково самостійно компілюйте і тестуйте свій код!

```plaintext
check50 cs50/problems/2023/x/cash
```

Якщо `check50` не вдається скомпілювати ваш код, переконайтеся, що ви змінили тільки ті частини програми, які позначені як `TODO`. Якщо ви змінили функцію `main` або додали глобальні змінні, наприклад, ваш код може **не скомпілюватись**. `check50` перевірить ваші п'ять функцій незалежно, не обмежуючись перевіркою лише кінцевої відповіді.

Ви також можете виконати команду нижче, щоб оцінити стиль вашого коду за допомогою `style50`.

```plaintext
style50 cash.c
```
