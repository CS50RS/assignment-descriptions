# Цезар

Для цього завдання ви реалізуєте програму, яка шифрує повідомлення з використанням шифру Цезаря, як показано нижче.

```plaintext
$ ./caesar 13
plaintext:  HELLO
ciphertext: URYYB
```

## Починаємо

Відкрийте [VS Code](https://cs50.dev/).

Почніть, натиснувши у вашому вікні терміналу, а потім виконайте команду `cd` без параметрів. Ви повинні побачити, що його "подсумок" схожий на нижчеприведений.

```plaintext
$
```

Клацніть всередині цього вікна терміналу, а потім виконайте

```plaintext
wget https://cdn.cs50.net/2022/fall/psets/2/caesar.zip
```

і натисніть Enter, щоб завантажити ZIP-файл з назвою `caesar.zip` у ваше середовище. При цьому слід дбати, щоб не пропустити пробіл між `wget` та наступним URL, або будь-яким іншим символом на той рахунок!

Тепер виконайте

```plaintext
unzip caesar.zip
```

щоб створити папку з назвою `caesar`. Вам більше не потрібний ZIP-файл, тому ви можете виконати

```plaintext
rm caesar.zip
```

і натиснути "y", а потім Enter у відповідь на запит, щоб видалити завантажений вами ZIP-файл.

Тепер введіть

```plaintext
cd caesar
```

і натисніть Enter, щоб перейти до цієї директорії. Тепер ваш "подсумок" повинен виглядати так:

```plaintext
caesar/ $
```

Якщо все пройшло успішно, ви можете виконати

```plaintext
ls
```

і побачити файл з назвою `caesar.c`. Виконання команди `code caesar.c` має відкрити файл, де ви будете вводити свій код для цієї задачі. Якщо ні, повторіть свої дії і подивіться, чи можете визначити, де ви помилились!

## Основи

Припустимо, що, як казав Цезар (так, той самий Цезар), він колись "шифрував" (тобто замасковував у зворотності) конфіденційні повідомлення, зсуваючи кожну літеру в ньому на деяку кількість місць. Наприклад, він міг написати A як B, B як C, C як D, ..., а також, обертаючи алфавітно, Z як A. Таким чином, щоб передати HELLO комусь, Цезар міг би написати IFMMP. Після отримання таких повідомлень від Цезаря, одержувачі мусіли б "дешифрувати" їх, зсуваючи літери в протилежному напрямку на ту саму кількість місць.

Таємність цього "криптосистеми" залежала від того, що лише Цезар та одержувачі знали секрет, кількість місць, на яку Цезар зсунув свої літери (наприклад, 1). Не особливо надійний за сучасними стандартами, але, якщо мати на увазі що ви перший у світі, хто це зробить, досить надійний!

Зазвичай незашифрований текст називають **початковим текстом**, а зашифрований текст називають **шифротекстом**. А секрет, використаний для шифрування, називають **ключем**.

Щоб уникнути недоліків, рекомендовано:

- шифрувати лише літери алфавіту (великі і малі), залишаючи решту символів без змін;
- зберігати великі і малі літери в початковому тексті, перетворюючи їх у великі і малі літери шифротексту.

Щоб уникнути втрати даних, рекомендовано:

- перетворювати лише літери латинського алфавіту (великі і малі);
- залишати інші символи без змін.

## Зашифруйте HELLO з ключем 1

```plaintext
HELLO -> IFMMP
```

| початковий текст | + ключ | = шифротекст |
| --------- | ----- | ------------ |
|   `H`     |   1   |      `I`     |
|   `E`     |   1   |      `F`     |
|   `L`     |   1   |      `M`     |
|   `L`     |   1   |      `M`     |
|   `O`     |   1   |      `P`     |

У формальному вираженні алгоритм Цезаря (тобто шифр) шифрує повідомлення, "повертаючи" кожну літеру на k позицій. Тобто, якщо p - деякий вихідний текст (незашифроване повідомлення), p_i - i-тий символ у p, а k - секретний ключ (невід'ємне ціле число), тоді кожна літера c_i в зашифрованому тексті c обчислюється як

```plaintext
c_i = (p_i + k) % 26
```

У цій формулі `%26` означає "остача від ділення на 26". Ця формула, можливо, робить шифр більш складним, ніж він є насправді, але насправді вона - просто лаконічний спосіб точного вираження алгоритму. Запам'ятайте, що для обговорення можна вважати, що A (або a) - це 0, B (або b) - 1 ..., H (або h) - 7, I (або i) - 8 ..., а Z (або z) - 25. Припустимо, що Цезар хоче просто поздороватись з кимось конфіденційно, використовуючи, на цей раз, ключ k рівний 3. Таким чином, його вихідний текст `p` - "Hi", у такому разі перший символ його вихідного тексту `p_0` - H (або 7), а другий символ його вихідного тексту `p_1` - i (або 8). Перший символ його зашифрованого тексту `c_0` тому дорівнює K, а другий символ його зашифрованого тексту `c_1` дорівнює L. Розумієте?

Напишемо програму під назвою caesar, яка дозволяє шифрувати повідомлення за допомогою шифру Цезаря. У момент виконання користувачем програми він повинен вирішити, задавши аргумент командного рядка, який вказує, яким буде ключ у секретному повідомленні, яке він надасть під час роботи програми. Ми не маємо вважати, що ключ користувача буде числом; хоча ви можете припускати, що, якщо це число, воно буде позитивним цілим числом.

Ось декілька прикладів того, як може працювати програма. Наприклад, якщо користувач вводить ключ 1 і вихідний текст HELLO:

```plaintext
$ ./caesar 1
plaintext:  HELLO
ciphertext: IFMMP
```

Ось як може працювати програма, якщо користувач вводить ключ 13 і вихідний текст hello, world:

```plaintext
$ ./caesar 13
plaintext:  hello, world
ciphertext: uryyb, jbeyq
```

Зверніть увагу, що ні кома, ні пробіл не були "зміщені" шифром. Тільки обертайте алфавітні символи!

Ще один? Ось як програма може працювати, якщо користувач вводить ключ `13` знову, з більш складним простим текстом:

```plaintext
$ ./caesar 13
plaintext:  be sure to drink your Ovaltine
ciphertext: or fher gb qevax lbhe Binygvar
```

Зверніть увагу, що регістр початкового повідомлення був збережений. Маленькі літери залишаються маленькими, а великі літери залишаються великими.

Що, якщо користувач не співпрацює, надавши аргумент командного рядка, який не є числом? Програма повинна нагадати користувачеві, як користуватися програмою:

```plaintext
$ ./caesar HELLO
Usage: ./caesar key
```

Або навіть не співпрацює, не надаючи жодного аргумента командного рядка? Програма повинна нагадати користувачеві, як користуватися програмою:

```plaintext
$ ./caesar
Usage: ./caesar key
```

Або навіть дуже, дуже не співпрацює, надавши більше одного аргумента командного рядка? Програма повинна нагадати користувачеві, як користуватися програмою:

```plaintext
$ ./caesar 1 2 3
Usage: ./caesar key
```

## Специфікація

Розробіть та реалізуйте програму `caesar`, яка шифрує повідомлення за допомогою шифру Цезаря.

- Реалізуйте вашу програму у файлі з назвою `caesar.c` в каталозі `caesar`.
- Ваша програма повинна приймати один єдиний аргумент командного рядка - невід'ємне ціле число. Нехай це буде `k` для зручності обговорення.
- Якщо вашу програму запущено без аргументів командного рядка або з більше ніж одним аргументом командного рядка, програма повинна вивести повідомлення про помилку на ваш вибір (за допомогою `printf`) і повернутися зі значенням `1` з `main` негайно, що зазвичай означає помилку.
- Якщо будь-який з символів аргумента командного рядка не є десятковою цифрою, ваша програма повинна вивести повідомлення `Використання: ./caesar ключ` і повернутися зі значенням `1` з `main`.
- Не передбачайте, що `k` буде менше або рівне 26. Ваша програма повинна працювати для всіх не-від'ємних цілочисельних значень `k`, менших за 2³¹ - 26. Іншими словами, вам не потрібно хвилюватися, якщо ваша програма врешті-решт зламається, якщо користувач обере значення `k`, що занадто велике або майже занадто велике, щоб поміститися в `int` (пам'ятайте, що `int` може переповнитися). Але, навіть якщо `k` більше 26, алфавітні символи у введенні вашої програми повинні залишатися алфавітними символами у виведенні вашої програми. Наприклад, якщо `k` дорівнює 27, `A` не повинне стати `\`, навіть якщо `\` знаходиться на 27 позицій далі від `A` в ASCII, за таблицею символів ASCII; `A` має стати `B`, оскільки `B` знаходиться на 27 позицій далі від `A`, з урахуванням замотування від `Z` до `A`.

- Ваша програма повинна вивести `plaintext:` (з двома пробілами, але без символу нового рядка) і потім попросити користувача ввести рядок тексту (за допомогою `get_string`).

- Ваша програма повинна вивести `ciphertext:` (з одним пробілом, але без символу нового рядка), а потім вивести відповідний криптотекст рядка тексту користувача, при цьому кожний алфавітний символ у вхідному тексті повинен бути "переміщений" на `k` позицій; не-алфавітні символи повинні залишатися без змін.

- Ваша програма повинна зберігати регістр: збережені букви, хоча і переміщені, повинні залишатися збереженими; збережені букви в нижньому регістрі, хоча і переміщені, повинні залишатися збереженими.

- Після виведення криптотексту програма повинна вивести символ нового рядка (`\n`). Потім програма повинна завершитися, повернувши `0` з функції `main`.

## Поради

Як почати? Давайте розглянемо цю задачу поступово.

### Псевдокод

Спочатку намагайтесь написати функцію `main` у файлі `caesar.c`, яка реалізує програму, використовуючи лише псевдокод, навіть якщо ви ще не впевнені, як написати його у справжньому коді.

Псевдокод може мати наступний вигляд:

```c
int main(void)
{
    // Переконайтеся, що програма запущена лише з одним аргументом командного рядка

    // Переконайтеся, що кожен символ у argv[1] є цифрою

    // Перетворіть argv[1] зі строки в int

    // Запитайте користувача про вхідний текст

    // Для кожного символу у вхідному тексті:
        // Перемістіть символ, якщо він є буквою
}
```

Ви можете редагувати свій власний псевдокод після того, як побачите наш. Не копіюйте/вставляйте наш псевдокод без змін.

### Рахування кількості аргументів

Почнемо з того, щоб у файлі `caesar.c` додати функціональність, яка перевірить, чи програма запущена з одним аргументом командного рядка, перш ніж додавати додатковий функціонал.

Зокрема, модифікуйте `main` так, щоб, якщо користувач не надасть аргументів командного рядка або надасть два або більше аргументів, функція виводила "Usage: ./caesar key\n" і повертала 1, тим самим закриваючи програму. Якщо користувач надасть точно один аргумент командного рядка, програма не повинна нічого друкувати і просто повертати 0. Програма повинна працювати за таким сценарієм:

```plaintext
$ ./caesar
Usage: ./caesar ключ
```

```plaintext
$ ./caesar 1 2 3
Usage: ./caesar ключ
```

```plaintext
$ ./caesar 1
```

<details><summary>Підказки</summary><ul>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-square"></i></span>Пам'ятайте, що ви можете друкувати за допомогою <code>printf</code>.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-square"></i></span>Пам'ятайте, що функція може повертати значення за допомогою <code>return</code>.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-square"></i></span>Пам'ятайте, що <code>argc</code> містить кількість аргументів командного рядка, переданих програмі, а також ім'я самої програми.</li>
</ul></details>

### Перевірка ключа

Тепер, коли ваша програма (сподіваємося!) приймає ввід за вказаним методом, настав час для наступного кроку.

Додайте до `caesar.c`, нижче `main`, функцію з назвою, наприклад, `only_digits`, яка приймає аргументом `string` та повертає `true`, якщо цей `string` містить тільки цифри, `0` до `9`, інакше повертає `false`. Впевніться також, що ви додаєте прототип функції перед `main`.

<details><summary>Підказки</summary><ul>
  <li data-marker="*">Імовірно, вам знадобиться прототип такого вигляду:
    <pre><code>bool only_digits(string s);</code></pre>
    Також не забудьте включити `cs50.h` у верхній частині вашого файлу, щоб компілятор розпізнавав тип `string` (і `bool`).
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-square"></i></span>Пам'ятайте, що <code>string</code> - це просто масив з символів типу <code>char</code>.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-square"></i></span>Пам'ятайте, що функція <code>strlen</code>, оголошена в <code>string.h</code>, обчислює довжину <code>string</code>.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-square"></i></span>Можливо, вам буде корисною функція <code>isdigit</code>, оголошена в <code>ctype.h</code>. Проте зауважте, що вона перевіряє лише один символ типу <code>char</code> за раз!</li>
</ul></details>

Тоді змініть `main` таким чином, щоб він викликає функцію `only_digits` на `argv[1]`. Якщо ця функція повертає `false`, тоді `main` повинен друкувати `"Usage: ./caesar key\n"` і повертати `1`. В іншому випадку `main` повинен просто повернути `0`. Програма повинна виконуватись таким чином:

```bash
$ ./caesar 42
```

```bash
$ ./caesar banana
```

### Використання ключа

Тепер змініть `main` таким чином, щоб він перетворював `argv[1]` у `int`. Можливо, ви знайдете корисною функцію `atoi`, оголошена в `stdlib.h`, див. [manual.cs50.io](https://manual.cs50.io). Потім використовуйте `get_string`, щоб запросити у користувача деякий текст з `plaintext:  `.

Потім реалізуйте функцію з назвою, наприклад, `rotate`, яка приймає `char` як вхідний параметр, а також `int`, і обертає цей `char` на стільки позицій, якщо він є літерою (тобто алфавітним символом), обертаючись від `Z` до `A` (і від `z` до `a`), якщо це необхідно. Якщо `char` не є літерою, функція повинна повертати той самий `char` без змін.

**Підказки**

- Імовірно, вам знадобиться прототип такого вигляду:

    ```c
    char rotate(char c, int n);
    ```

    Виклик функції такого вигляду:

    ```c
    rotate('A', 1)
    ```

    або навіть

    ```c
    rotate('A', 27)
    ```

    повинен повертати `'B'`. А виклик функції такого вигляду:

    ```c
    rotate('!', 13)
    ```

    повинен повертати `'!'`.
- Пам'ятайте, що можна явно "перетворити" `char` в `int` за допомогою `(char)`, а `int` в `char` за допомогою `(int)`. Або ви можете зробити це неявно, просто розглядаючи один як інший.
- Імовірно, ви захочете відняти від ASCII-значення `A` будь-яку велику літеру, щоб `A` вважати `0`, `B` - `1` і так далі, під час виконання арифметичних операцій. Потім додайте його назад, коли закінчите з тим самим.
- Імовірно, ви захочете відняти від ASCII-значення `a` будь-яку малу літеру, щоб `a` вважати `0`, `b` - `1` і так далі, під час виконання арифметичних операцій. Потім додайте його назад, коли закінчите з тим самим.
- Можливо, ви знайдете деякі інші функції, оголошені в `ctype.h`, корисними, див. [manual.cs50.io](https://manual.cs50.io).
- Імовірно, ви знайдете оператор `%` корисним для "закручування" арифметично від значення, наприклад, `25` до `0`.

Тоді змініть `main` таким чином, щоб він друкував `"ciphertext: "` і потім ітерувався по кожному `char` вхідного тексту користувача, викликаючи `rotate` на кожному символі і друкуючи повернений значення.

**Підказки**

- Пам'ятайте, що `printf` може друкувати `char` за допомогою `%c`.
- Якщо ви не бачите жодного виводу під час виклику `printf`, ймовірно, це тому, що ви друкуєте символи за межами дійсного діапазону ASCII від 0 до 127. Спробуйте тимчасово друкувати символи як числа (використовуючи `%i` замість `%c`), щоб побачити значення, які ви друкуєте!

### Як перевірити свій код

Виконайте нижче наведене, щоб оцінити правильність вашого коду за допомогою `check50`. Але не забудьте самостійно скомпілювати та перевірити його!

```plaintext
check50 cs50/problems/2023/x/caesar
```

Виконайте нижче наведене, щоб оцінити стиль вашого коду за допомогою `style50`.

```plaintext
style50 caesar.c
```
